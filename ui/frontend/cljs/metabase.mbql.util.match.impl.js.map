{"version":3,"sources":["metabase/mbql/util/match/impl.cljc"],"mappings":"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","names":["metabase.mbql.util.match.impl/match-with-pred-or-class","pred-or-class","cljs.core/fn?","cljs.core.ex_info","js/Error","metabase.mbql.util.match.impl/match-in-collection","match-fn","clause-parents","form","cljs.core/vector?","cljs.core/map?","cljs.core.reduce","cljs.core/concat","iter__4529__auto__","s__39558","cljs.core/LazySeq","temp__5735__auto__","cljs.core/seq","cljs.core/chunked-seq?","c__4527__auto__","size__4528__auto__","cljs.core/count","b__39560","cljs.core/chunk-buffer","i__39559","vec__39569","cljs.core/-nth","cljs.core.nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__39557","cljs.core/chunk-rest","vec__39577","cljs.core/first","cljs.core/cons","cljs.core/rest","k","v","G__39572","G__39573","G__39580","G__39581","cljs.core.conj","cljs.core/sequential?","cljs.core.mapcat","cljs.core.partial","cljs.core/Keyword","metabase.mbql.util.match.impl/replace-in-collection","replace-fn","cljs.core.into","s__39594","b__39596","i__39595","vec__39606","iter__39593","vec__39614","G__39609","G__39610","G__39618","G__39619","cljs.core.mapv","var_args","args__4742__auto__","len__4736__auto__","i__4737__auto__","argseq__4743__auto__","cljs.core/IndexedSeq","metabase.mbql.util.match.impl/update-in-unless-empty","seq39634","G__39635","cljs.core/next","G__39636","G__39637","self__4723__auto__","m","ks","f","args","cljs.core/not","cljs.core.get_in","cljs.core.apply","cljs.core/update-in","cljs.core/chunk-first"],"sourcesContent":["(ns metabase.mbql.util.match.impl\n  \"Internal implementation of the MBQL `match` and `replace` macros. Don't use these directly.\")\n\n;; have to do this at runtime because we don't know if a symbol is a class or pred or whatever when we compile the macro\n(defn match-with-pred-or-class\n  \"Return a function to use for pattern matching via `core.match`'s `:guard` functionality based on the value of a\n  `pred-or-class` passed in as a pattern to `match` or `replace`.\n\n  (Class-based matching currently only works in Clojure. For ClojureScript, only predicate function matching works.)\"\n  [pred-or-class]\n  (cond\n    ;; TODO -- FIXME -- Figure out how to make this work in JS\n    #?@(:clj [(class? pred-or-class)\n              (partial instance? pred-or-class)])\n\n    (fn? pred-or-class)\n    pred-or-class\n\n    :else\n    ;; this is dev-specific so we don't need to localize it\n    (throw (ex-info \"Invalid pattern: don't know how to handle symbol.\" {:symbol pred-or-class}))))\n\n(defn match-in-collection\n  \"Internal impl for `match`. If `form` is a collection, call `match-fn` to recursively look for matches in it.\"\n  [match-fn clause-parents form]\n  {:pre [(fn? match-fn) (vector? clause-parents)]}\n  (cond\n    (map? form)\n    (reduce concat (for [[k v] form]\n                     (match-fn (conj clause-parents k) v)))\n\n    (sequential? form)\n    (mapcat (partial match-fn (if (keyword? (first form))\n                                (conj clause-parents (first form))\n                                clause-parents))\n            form)))\n\n(defn replace-in-collection\n  \"Inernal impl for `replace`. Recursively replace values in a collection using a `replace-fn`.\"\n  [replace-fn clause-parents form]\n  (cond\n    (map? form)\n    (into form (for [[k v] form]\n                 [k (replace-fn (conj clause-parents k) v)]))\n\n    (sequential? form)\n    (mapv (partial replace-fn (if (keyword? (first form))\n                                (conj clause-parents (first form))\n                                clause-parents))\n          form)\n    :else              form))\n\n(defn update-in-unless-empty\n  \"Like `update-in`, but only updates in the existing value is non-empty.\"\n  [m ks f & args]\n  (if-not (seq (get-in m ks))\n    m\n    (apply update-in m ks f args)))\n"]}