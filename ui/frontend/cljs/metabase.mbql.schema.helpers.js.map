{"version":3,"sources":["metabase/mbql/schema/helpers.cljc"],"mappings":"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","names":["metabase.mbql.schema.helpers/clause-arg-schema","arg-name","arg-schema","cljs.core/vector?","schema.core/one","vec__42392","cljs.core.nth","option","vector-arg-schema","G__42395","cljs.core/Keyword","schema.core/optional","schema.core/maybe","schema.core/named","var_args","args__4742__auto__","len__4736__auto__","i__4737__auto__","argseq__4743__auto__","cljs.core/IndexedSeq","metabase.mbql.schema.helpers/clause","seq42396","G__42397","cljs.core/first","cljs.core/next","self__4723__auto__","clause-name","arg-schemas","cljs.core/vec","cljs.core/cons","schema.core/eq","iter__4529__auto__","s__42400","cljs.core/LazySeq","temp__5735__auto__","cljs.core/seq","cljs.core/chunked-seq?","c__4527__auto__","size__4528__auto__","cljs.core/count","b__42402","cljs.core/chunk-buffer","i__42401","vec__42404","cljs.core/-nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__42399","cljs.core/chunk-rest","vec__42409","cljs.core/rest","cljs.core.partition","metabase.mbql.schema.helpers/is-clause?","k-or-ks","x","cljs.core/sequential?","cljs.core/coll?","G__42417","fexpr__42416","cljs.core/set","cljs.core._EQ_","metabase.mbql.schema.helpers/one-of*","seq42418","self__4724__auto__","clause-names+schemas","cljs.core.apply","schema.core/conditional","cljs.core.reduce","cljs.core/concat","s__42421","b__42423","i__42422","vec__42424","iter__42420","vec__42427","schema","cljs.core.partial","clojure.string.join","cljs.core.map","metabase.mbql.schema.helpers/NonBlankString","schema.core.constrained","schema.core/Str","cljs.core/complement","clojure.string/blank?","metabase.mbql.schema.helpers/FieldType","p1__42430#","schema.core.pred","cljs.core.isa_QMARK_","metabase.mbql.schema.helpers/FieldSemanticOrRelationType","k","metabase.mbql.schema.helpers/IntGreaterThanZero","schema.core/Int","cljs.core/pos?","metabase.mbql.schema.helpers/IntGreaterThanOrEqualToZero","cljs.core/neg?","metabase.mbql.schema.helpers/Map","schema.core/Any","metabase.mbql.schema.helpers/KeywordOrString","schema.core.cond_pre","schema.core/Keyword","metabase.mbql.schema.helpers/non-empty","metabase.mbql.schema.helpers/empty-or-distinct?","coll","cljs.core/distinct?","metabase.mbql.schema.helpers/distinct","cljs.core/chunk-first"],"sourcesContent":["(ns metabase.mbql.schema.helpers\n  (:refer-clojure :exclude [distinct])\n  (:require [clojure.string :as str]\n            metabase.types\n            [schema.core :as s]))\n\n(comment metabase.types/keep-me)\n\n;;; --------------------------------------------------- defclause ----------------------------------------------------\n\n(defn- clause-arg-schema [arg-name arg-schema]\n  ;; for things like optional schemas\n  (if-not (vector? arg-schema)\n    (s/one arg-schema arg-name)\n    (let [[option arg-schema :as vector-arg-schema] arg-schema]\n      (case option\n        :optional (s/optional (s/maybe arg-schema) arg-name)\n        :rest     (s/named arg-schema arg-name)\n        (s/one vector-arg-schema arg-name)))))\n\n(defn clause\n  \"Impl of `defclause` macro.\"\n  [clause-name & arg-schemas]\n  (vec\n   (cons\n    (s/one (s/eq clause-name) clause-name)\n    (for [[arg-name arg-schema] (partition 2 arg-schemas)]\n      (clause-arg-schema arg-name arg-schema)))))\n\n\n;; TODO - this is a copy of the one in the `metabase.mbql.util` namespace. We need to reorganize things a bit so we\n;; can use the same fn and avoid circular refs\n(defn is-clause?\n  \"If `x` an MBQL clause, and an instance of clauses defined by keyword(s) `k-or-ks`?\n\n    (is-clause? :count [:count 10])        ; -> true\n    (is-clause? #{:+ :- :* :/} [:+ 10 20]) ; -> true\"\n  [k-or-ks x]\n  (and\n   (sequential? x)\n   (keyword? (first x))\n   (if (coll? k-or-ks)\n     ((set k-or-ks) (first x))\n     (= k-or-ks (first x)))))\n\n(defn one-of*\n  \"Interal impl of `one-of` macro.\"\n  [& clause-names+schemas]\n  (s/named\n   (apply\n    s/conditional\n    (reduce concat (for [[clause-name schema] clause-names+schemas]\n                     [(partial is-clause? clause-name) schema])))\n   (str \"Must be a valid instance of one of these clauses: \" (str/join \", \" (map first clause-names+schemas)))))\n\n(def NonBlankString\n  \"Schema for a string that isn't blank.\"\n  (s/constrained s/Str (complement str/blank?) \"Non-blank string\"))\n\n(def FieldType\n  \"Schema for `:type/*` or one of its descendants in the Metabase type hierarchy.\"\n  (s/pred #(isa? % :type/*) \"Valid field type\"))\n\n(def FieldSemanticOrRelationType\n  \"Schema for a `:Semantic/*` (or `:Relation/*`, until we fix this) or one of their descendents in the Metabase\n  Hierarchical Type System (MHTS).\"\n  (s/pred (fn [k]\n            (or (isa? k :Semantic/*)\n                (isa? k :Relation/*)))\n          \"Valid semantic type\"))\n\n(def IntGreaterThanZero\n  \"Schema for a positive integer.\"\n  (s/constrained s/Int pos? \"positive integer\"))\n\n(def IntGreaterThanOrEqualToZero\n  \"Schema for an integer >= zero.\"\n  (s/constrained s/Int (complement neg?) \"integer >= 0\"))\n\n(def Map\n  \"Schema for any map.\"\n  {s/Any s/Any})\n\n(def KeywordOrString\n  \"Schema for any keyword or string.\"\n  (s/cond-pre s/Keyword s/Str))\n\n(defn non-empty\n  \"Add an addditonal constraint to `schema` (presumably an array) that requires it to be non-empty\n   (i.e., it must satisfy `seq`).\"\n  [schema]\n  (s/constrained schema seq \"Non-empty\"))\n\n(defn empty-or-distinct?\n  \"True if `coll` is either empty or distinct.\"\n  [coll]\n  (if (seq coll)\n    (apply distinct? coll)\n    true))\n\n(defn distinct\n  \"Add an additional constraint to `schema` (presumably an array) that requires all elements to be distinct.\"\n  [schema]\n  (s/constrained schema empty-or-distinct? \"distinct\"))\n"]}