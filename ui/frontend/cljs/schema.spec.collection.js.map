{"version":3,"sources":["schema/spec/collection.cljs"],"mappings":"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","names":["schema.spec.collection/element-transformer","e","params","then","cljs.core/vector?","G__41316","cljs.core/Keyword","js/Error","cljs.core/first","G__41319","G__41320","G__41321","schema.spec.collection/sequence-transformer","cljs.core/next","_","schema.utils/format*","cljs.core._EQ_","cljs.core/count","c","schema.spec.core/sub-checker","cljs.core/second","res","x","cljs.core.swap_BANG_","cljs.core/into","cljs.core.map","parser","G__41326","G__41327","G__41328","G__41329","t","cljs.core/conj","schema.utils/error?","elts","p1__41334#","cljs.core/not-any?","cljs.core/butlast","cljs.core.reduce","f","cljs.core/reverse","schema.spec.collection/has-error?","l","cljs.core/some","schema.spec.collection/subschemas","elt","cljs.core/map?","G__41365","fexpr__41364","cljs.core.mapcat","this__4380__auto__","k__4381__auto__","this__4382__auto__","k41371","else__4383__auto__","G__41383","pre","constructor","elements","on-error","cljs.core.get","__extmap","this__4399__auto__","f__4400__auto__","init__4401__auto__","ret__4402__auto__","p__41387","vec__41388","k__4403__auto__","cljs.core.nth","v__4404__auto__","cljs.core/PROTOCOL_SENTINEL","this__4394__auto__","writer__4395__auto__","opts__4396__auto__","pr-pair__4397__auto__","keyval__4398__auto__","cljs.core/pr-sequential-writer","cljs.core.concat","cljs.core/PersistentVector","G__41370","cljs.core/RecordIter","cljs.core/-iterator","cljs.core/nil-iter","this__4378__auto__","__meta","this__4375__auto__","__hash","this__4384__auto__","this__4376__auto__","h__4238__auto__","coll__4377__auto__","cljs.core/hash-unordered-coll","this41372","other41373","this__4389__auto__","k__4390__auto__","cljs.core/contains?","cljs.core.dissoc","cljs.core/-with-meta","cljs.core.into","cljs.core/not-empty","this__4387__auto__","k__4388__auto__","pred__41421","cljs.core/keyword-identical?","expr__41422","cljs.core.assoc","this__4392__auto__","cljs.core/seq","cljs.core/MapEntry","this__4379__auto__","this__4385__auto__","entry__4386__auto__","cljs.core/-nth","cljs.core/-conj","schema.spec.collection/CollectionSpec","this__4423__auto__","cljs.core/List","writer__4424__auto__","cljs.core/-write","G__41378","extmap__4419__auto__","G__41439","cljs.core/record?","schema.spec.collection/->CollectionSpec","schema.spec.collection/map->CollectionSpec","this","or__4126__auto__","cljs.core/deref","cljs.core.atom","remaining","schema.utils/error","schema.spec.collection/collection-spec","schema.spec.collection/remaining","s","var_args","args__4742__auto__","len__4736__auto__","i__4737__auto__","argseq__4743__auto__","cljs.core/IndexedSeq","schema.spec.collection/optional","seq41444","self__4724__auto__","ss","cljs.core/vec","cljs.core/cons","schema.spec.collection/all-elements","schema","coll","schema.spec.collection/one-element","required?","base","schema.spec.collection.optional","schema.spec.collection/optional-tail","more"],"sourcesContent":["(ns schema.spec.collection\n  \"A collection spec represents a collection of elements,\n   each of which is itself schematized.\"\n  (:require\n                                   \n   [schema.utils :as utils]\n   [schema.spec.core :as spec])\n         (:require-macros [schema.macros :as macros]))\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Collection Specs\n\n(declare sequence-transformer)\n\n(defn- element-transformer [e params then]\n  (if (vector? e)\n    (case (first e)\n      ::optional\n      (sequence-transformer (next e) params then)\n\n      ::remaining\n      (let [_ (macros/assert! (= 2 (count e)) \"remaining can have only one schema.\")\n            c (spec/sub-checker (second e) params)]\n                                         \n                            \n                                   \n                               \n               (fn [res x]\n                 (swap! res into (map c x))\n                 (then res nil))))\n\n    (let [parser (:parser e)\n          c (spec/sub-checker e params)]\n                                       \n                                                                                      \n             (fn [res x]\n               (then res (parser (fn [t] (swap! res conj (if (utils/error? t) t (c t)))) x))))))\n\n(defn- sequence-transformer [elts params then]\n  (macros/assert! (not-any? #(and (vector? %) (= (first %) ::remaining)) (butlast elts))\n                  \"Remaining schemas must be in tail position.\")\n  (reduce\n   (fn [f e]\n     (element-transformer e params f))\n   then\n   (reverse elts)))\n\n                        \n                                     \n                         \n            \n                       \n                                     \n              \n                  \n                 \n\n      \n(defn- has-error? [l]\n  (some utils/error? l))\n\n(defn subschemas [elt]\n  (if (map? elt)\n    [(:schema elt)]\n    (do (assert (vector? elt))\n        (assert (#{::remaining ::optional} (first elt)))\n        (mapcat subschemas (next elt)))))\n\n(defrecord CollectionSpec [pre constructor elements on-error]\n  spec/CoreSpec\n  (subschemas [this] (mapcat subschemas elements))\n  (checker [this params]\n    (let [constructor (if (:return-walked? params) constructor (fn [_] nil))\n          t (sequence-transformer elements params (fn [_ x] x))]\n      (fn [x]\n        (or (pre x)\n            (let [res                                     (atom [])\n                  remaining (t res x)\n                  res                  @res]\n              (if (or (seq remaining) (has-error? res))\n                (utils/error (on-error x res remaining))\n                (constructor res))))))))\n\n\n(defn collection-spec\n  \"A collection represents a collection of elements, each of which is itself\n   schematized.  At the top level, the collection has a precondition\n   (presumably on the overall type), a constructor for the collection from a\n   sequence of items, an element spec, and a function that constructs a\n   descriptive error on failure.\n\n   The element spec is a nested list structure, in which the leaf elements each\n   provide an element schema, parser (allowing for efficient processing of structured\n   collections), and optional error wrapper.  Each item in the list can be a leaf\n   element or an `optional` nested element spec (see below).  In addition, the final\n   element can be a `remaining` schema (see below).\n\n   Note that the `optional` carries no semantics with respect to validation;\n   the user must ensure that the parser enforces the desired semantics, which\n   should match the structure of the spec for proper generation.\"\n  [pre ;- spec/Precondition\n   constructor ;- (s/=> s/Any [(s/named s/Any 'checked-value)])\n   elements ;- [(s/cond-pre\n   ;;            {:schema (s/protocol Schema)\n   ;;             :parser (s/=> s/Any (s/=> s/Any s/Any) s/Any) ; takes [item-fn coll], calls item-fn on matching items, returns remaining.\n   ;;             (s/optional-key :error-wrap) (s/pred fn?)}\n   ;;            [(s/one ::optional) (s/recursive Elements)]]\n   ;;          where the last element can optionally be a [::remaining schema]\n   on-error ;- (=> s/Any (s/named s/Any 'value) [(s/named s/Any 'checked-element)] [(s/named s/Any 'unmatched-element)])\n   ]\n  (->CollectionSpec pre constructor elements on-error))\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Helpers for creating 'elements'\n\n(defn remaining\n  \"All remaining elements must match schema s\"\n  [s]\n  [::remaining s])\n\n(defn optional\n  \"If any more elements are present, they must match the elements in 'ss'\"\n  [& ss]\n  (vec (cons ::optional ss)))\n\n(defn all-elements [schema]\n  (remaining\n   {:schema schema\n    :parser (fn [coll] (macros/error! (str \"should never be not called\")))}))\n\n(defn one-element [required? schema parser]\n  (let [base {:schema schema :parser parser}]\n    (if required?\n      base\n      (optional base))))\n\n(defn optional-tail [schema parser more]\n  (into (optional {:schema schema :parser parser}) more))\n\n;;;;;;;;;;;; This file autogenerated from src/cljx/schema/spec/collection.cljx\n"]}