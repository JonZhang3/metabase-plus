{"version":3,"sources":["schema/spec/core.cljs"],"mappings":";;;;;;;;;;;;;;;;;;;;AAWA,AAAA;AAAA;;;;;;AAAA,AAAaS;;AAAb,AAAAT,AAAA,AAIeU;AAJf,AAAA,AAAAT,AAAA,AAAA,AAAA,AAAA,AAIeS,AAAAA;AAJfR,AAAA,AAAAC,AAAA,AAAAC,AAAAH;AAAA,AAAA,AAAA,AAAA,AAAAC,AAAA;AAAA,AAAAA,AAAAA,AAAAA,AAIeQ,AAAAA;;AAJf,AAAAL,AAAA,AAAAF,AAAA;AAAA,AAAA,AAAA,AAAA,AAAAE,AAAA;AAAA,AAAAA,AAAAA,AAAAA,AAIeK,AAAAA;;AAJf,AAAA,AAAAJ,AAAA,AAIeI;;;;AAJf,AAAA;;;AAAA,AAIGP,AAAYO;AAJf,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAIeA,AAAAA;AAJf,AAIeA,AAAAA;;AAJf,AAAAV,AAIeU;;;;AAJf,AAAAH,AAAA,AAMYG,AAAKC;AANjB,AAAA,AAAAV,AAAA,AAAA,AAAA,AAAA,AAMYS,AAAAA;AANZR,AAAA,AAAAM,AAAA,AAAAJ,AAAAH;AAAA,AAAA,AAAA,AAAA,AAAAC,AAAA;AAAA,AAAAA,AAAAA,AAAAA,AAMYQ,AAAAA,AAAKC,AAAAA;;AANjB,AAAAN,AAAA,AAAAG,AAAA;AAAA,AAAA,AAAA,AAAA,AAAAH,AAAA;AAAA,AAAAA,AAAAA,AAAAA,AAMYK,AAAAA,AAAKC,AAAAA;;AANjB,AAAA,AAAAL,AAAA,AAMYI;;;;AANZ,AAAA;;;;;;;;;;;;;;;AAAA,AAMGF,AAASE,AAAKC;AANjB,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAMYD,AAAAA;AANZ,AAMYA,AAAAA,AAAKC;;AANjB,AAAAJ,AAMYG,AAAKC;;;;AANjB,AA+BA,AAAKC,AAAkB,AAAKC;AAAL,AAAA;;AAEvB;;;;;;;AAAA,AAAMC,AAMHC,AAAEC,AAAEC;AANP,AAOE,AAAKC;AAAL,AACE,AAAAC,AAAkB,AAAA,AAAqB,AAAU,AAACH,AAAAA,AAAAA,AAAEE,AAAAA;AAAb;;AAAA,AAAA,AAAA;;AAArB,AAAA,AAAAG,AAAAC;AAAA,AAAAD,AAAkDE;AAAlD,AAAA,AAAA;;AAAA,AAAA,AAAAF;;;;AAAlB,AAAA,AAAAF;AAAA,AAAA,AAAAA,AAAWC;AAAX,AACE,AAAAI,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAyBX,AAAEG;AAA3B,AAA6B,AAAAS,AAAO,AAACC,AAAiBV;AAAzB,AAAA,AAAAS,AAAAA,AAACV,AAAAA,AAAAA;AAA9B,AAA0DG;;AAD5D;;;;AAYJ;;;;AAAA,AAAMS,AAGHC,AAAEC,AAAehB;AAHpB,AAIE,AAAAiB,AACCjB;AADDkB,AAAA,AAAA,AAAA,AAAA,AAEqBH,AACHC,AACiC,AAAA,AAACG;AAJpD,AAAA,AAAAF,AAAAC,AAAAD,AAAAC,AAACH,AAAAA,AAAAA;;AAMH,AAAA,AAAMK,AAAYC,AAAMC,AAAUC,AAAqBC;AAAvD,AACE,AAAAC,AAA8D,AAAAE,AAAA,AAAAC,AAAEP;AAAF,AAAA,AAAAM,AAAAA,AAAAA,AAAQL,AAAAA;;AAAtE,AAAA,AAAAG;AAAA,AAAAA,AAASC;AAAT,AACE,AAAI,AAAA,AAACG,AAAgBH;AACnB,AAAAI,AAAsB,AAAAnB,AAAA;AAAA,AAA0D,AAAAoB,AAAA,AAAAH,AAAEP;AAAF,AAAA,AAAAU,AAAAA,AAAAA,AAAQT,AAAAA;AAAlE;AAAtB,AAAA,AAAAQ,AAAAA,AAACP,AAAAA,AAAAA;;AACDG;;;AACF,AAAqE,AAAA,AAACM,AAAMX,AAAMY,AAAMX;;AACpF,AAAMY,AAAI,AAACV,AAAAA,AAAAA;AAAX,AACyD,AAACQ,AAAMX,AAAMY,AAAMX,AAAUY;;AACpFA;;;AAEV;;;;AAAA,AAAAC,AAAAC,AAAMO;AAAN,AAAA,AAAAN,AAAAF;AAAAE,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAC,AAAA,AAAAD,AAAA,AAAA,AAAA,AAAA,AAAAE,AAAAC,AAAAH,AAAAA;AAAA,AAAAI,AAAAJ,AAAA,AAGWO;AAHX,AAAAH,AAAAJ,AAAA,AAGkBQ;AAHlBH,AAAAN;AAAAM,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAJ,AAAA,AAAAI,AAAA,AAAA,AAAA,AAAA,AAAAH,AAAAC,AAAAE,AAAAA;AAAAA,AAIwC9C;AAJxC,AAAA6C,AAAAC,AAAA,AAIWI;AAJX,AAAAL,AAAAC,AAAA,AAI6BrB;AAJ7B,AAKE,AAAM0B,AAAI,AAAC3B,AAAWC,AAAMuB,AAChB,AAAKI;AAAL,AAAQ,AAAK7C;AAAL,AAAQ,AAAA8C,AAAA,AAAArB,AAAEoB;AAAF,AAAA,AAAAC,AAAAA,AAAAA,AAAI9C,AAAAA;;AACpB;AAAA,AAAO,AAAC2C,AAAAA,AAAAA,AAAkBF,AAAAA,AAAOhD,AAAAA;;AAF7C,AAGE,AAAIiD;AACF,AAAK1C;AAAL,AACE,AAAM+B,AAAI,AAACa,AAAAA,AAAAA,AAAI5C,AAAAA;AAAf,AACE,AAAAsB,AAAW,AAAC0B,AAAgBjB;AAA5B,AAAA,AAAAT;AAAA,AAAAA,AAASyB;AAAT,AACE,AAACzC,AAAY,AAACoC,AAAAA,AAAAA,AAAWX,AAAAA;;AACzBA;;;;AACNa","names":["schema$spec$core$CoreSpec$subschemas$dyn","x__4428__auto__","m__4429__auto__","schema.spec.core/subschemas","goog/typeOf","m__4426__auto__","cljs.core/missing-protocol","schema$spec$core$CoreSpec$checker$dyn","schema.spec.core/checker","schema.spec.core/CoreSpec","this","params","schema.spec.core/+no-precondition+","_","schema.spec.core/precondition","s","p","err-f","x","temp__5735__auto__","reason","e37390","js/Object","e#","schema.utils/error","schema.utils/make-ValidationError","cljs.core/Delay","G__37391","schema.utils/value-name","schema.spec.core/run-checker","f","return-walked?","G__37392","G__37393","cljs.core.atom","schema.spec.core/with-cache","cache","cache-key","wrap-recursive-delay","result-fn","temp__5733__auto__","w","fexpr__37398","cljs.core/deref","cljs.core._EQ_","G__37401","fexpr__37403","cljs.core.swap_BANG_","cljs.core/assoc","res","p__37405","p__37406","map__37407","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","cljs.core.get","map__37408","schema.spec.core/sub-checker","schema","error-wrap","subschema-checker","sub","d","fexpr__37413","e","schema.utils/error-val"],"sourcesContent":["(ns schema.spec.core\n  \"Protocol and preliminaries for Schema 'specs', which are a common language\n   for schemas to use to express their structure.\"\n  (:require\n                                   \n   [schema.utils :as utils])\n         (:require-macros [schema.macros :as macros]))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Core spec protocol\n\n(defprotocol CoreSpec\n  \"Specs are a common language for Schemas to express their structure.\n   These two use-cases aren't priveledged, just the two that are considered core\n   to being a Spec.\"\n  (subschemas [this]\n    \"List all subschemas\")\n  (checker [this params]\n    \"Create a function that takes [data], and either returns a walked version of data\n     (by default, usually just data), or a utils/ErrorContainer containing value that looks\n     like the 'bad' parts of data with ValidationErrors at the leaves describing the failures.\n\n     params are: subschema-checker, return-walked?, and cache.\n\n     params is a map specifying:\n      - subschema-checker - a function for checking subschemas\n      - returned-walked? - a boolean specifying whether to return a walked version of the data\n        (otherwise, nil is returned which increases performance)\n      - cache - a map structure from schema to checker, which speeds up checker creation\n        when the same subschema appears multiple times, and also facilitates handling\n        recursive schemas.\"))\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Preconditions\n\n;; A Precondition is a function of a value that returns a\n;; ValidationError if the value does not satisfy the precondition,\n;; and otherwise returns nil.\n;; e.g., (s/defschema Precondition (s/=> (s/maybe schema.utils.ValidationError) s/Any))\n;; as such, a precondition is essentially a very simple checker.\n\n(def +no-precondition+ (fn [_] nil))\n\n(defn precondition\n  \"Helper for making preconditions.\n   Takes a schema, predicate p, and error function err-f.\n   If the datum passes the predicate, returns nil.\n   Otherwise, returns a validation error with description (err-f datum-description),\n   where datum-description is a (short) printable standin for the datum.\"\n  [s p err-f]\n  (fn [x]\n    (when-let [reason (macros/try-catchall (when-not (p x) 'not) (catch e# 'throws?))]\n      (macros/validation-error s x (err-f (utils/value-name x)) reason))))\n\n                             \n                                                                                           \n           \n                                                     \n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Helpers\n\n(defn run-checker\n  \"A helper to start a checking run, by setting the appropriate params.\n   For examples, see schema.core/checker or schema.coerce/coercer.\"\n  [f return-walked? s]\n  (f\n   s\n   {:subschema-checker f\n    :return-walked? return-walked?\n    :cache                                           (atom {})}))\n\n(defn with-cache [cache cache-key wrap-recursive-delay result-fn]\n  (if-let [w                                                    (@cache cache-key)]\n    (if (= ::in-progress w) ;; recursive\n      (wrap-recursive-delay (delay                                                    (@cache cache-key)))\n      w)\n    (do                                                                  (swap! cache assoc cache-key ::in-progress)\n        (let [res (result-fn)]\n                                                                 (swap! cache assoc cache-key res)\n          res))))\n\n(defn sub-checker\n  \"Should be called recursively on each subschema in the 'checker' method of a spec.\n   Handles caching and error wrapping behavior.\"\n  [{:keys [schema error-wrap]}\n   {:keys [subschema-checker cache] :as params}]\n  (let [sub (with-cache cache schema\n              (fn [d] (fn [x] (@d x)))\n              (fn [] (subschema-checker schema params)))]\n    (if error-wrap\n      (fn [x]\n        (let [res (sub x)]\n          (if-let [e (utils/error-val res)]\n            (utils/error (error-wrap res))\n            res)))\n      sub)))\n\n;;;;;;;;;;;; This file autogenerated from src/cljx/schema/spec/core.cljx\n"]}