{"version":3,"sources":["metabase/types/coercion_hierarchies.cljc"],"mappings":";;;;;;;;;;;;;;;;;;;;AAMA,AAAA,AAAAA,AAAAC,AAAAC,AAAAC;AAAA;AAAA,AAAA;;;AAEEC,AACA,AAAA,AAACC;;AAEH,AAAA,AAAAL,AAAAC,AAAAC,AAAAI;AAAA;AAAA,AAAA;;;AAEEC,AACA,AAAA,AAACF;;AAEH,AAAA,AAAAL,AAAAC,AAAAC,AAAAM;AAAA;AAAA,AAAA;;;;;AAIEC,AACA,AAAA,AAACJ;;AAEH;;;AAAA,AAAMM;AAAN,AAAA,AAAAD,AAGGD;;AAEH;;;;AAAA,AAAMG,AAGHC;AAHH,AAIE,AAAA,AAAAH,AAACI,AAAKP,AAAyBM;;AAEjC;;;AAAA,AAAOE,AAEJC;AAFH,AAGE,AAAI,AAAC,AAACC,AAAQC,AAAYC,AAAKC,AAAMJ;AAAGA;;AAAxC,AAA2CA;;;AAE7C;;;AAAA,AAAMK,AAEHC,AAAkBC,AAAmBC;AAFxC,AAGE,AAAMC,AAAW,AAACC,AAAI,AAACX,AAAYQ;AAAnC,AACE,AAACI,AAAMvB,AAA6BwB,AAAMN,AAAkBG;;AAC9D,AAACE,AAAMpB,AAAyBqB,AAAMN,AAAkBE;;AAE1D;;;AAAA,AAAMK,AAEHP,AAAkBC,AAAmBC;AAFxC,AAGE,AAACG,AAAMlB,AACA,AAACqB,AAAQC,AAAWC,AACpB,AAACC,AAAO,AAAClB,AAAYQ,AAAoB,AAAA,AAACW,AAASZ;;AAC1D,AAACK,AAAMpB,AAAyBqB,AAAMN,AAAkBE;;AAE1D,AAAA,AAAOW,AAAiBC;AAAxB,AACE,AAACC,AACA,AAAAC,AAAKG;AAAL,AAAA,AAAAF,AAAAD;AAAA,AAAAE,AAAAD,AAAA,AAAA,AAAQG;AAAR,AAAAF,AAAAD,AAAA,AAAA,AAAYI;AAAZ,AACE,AAACC,AAAOH,AAAEC,AAAIC;AAFjB,AAAAjC,AAIW,AAAAmC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAC,AAAA,AAAA,AAAAA,AAAA;AAAA,AAAA,AAAAD,AAAAA,AAAAA;AACVT;;AAIH,AAAeW,AACb,AAAA,AAAC1C;AAEH;;;AAAA,AAAM2C;AAAN,AAGE,AAAA,AAAAtC,AAAWqC;AAAX;AAAA,AACE,AACE,AAAA,AAAArC,AAAWqC;AAAX;AAAA,AACE,AAACE,AAAOF,AAAqB,AAACZ,AAAgB,AAAAe,AAAA,AAAAC;AAAA,AAAA,AAAAC,AAAA,AAAA;AAAA,AAAA,AAAAD,AAAAA;;AAAA,AAAA,AAAAE,AAAA,AAAAC,AAAAH;AAAA,AAAA,AAAAE;AAAA,AAAA,AAAAE,AAAAF;AAAA,AAAA,AAAAG,AAAA,AAAAC,AAAAF;AAAA,AAAAf,AAAAgB,AAAA,AAAA,AAAO3C;AAAP,AAAA2B,AAAAgB,AAAA,AAAA,AAAgB/B;AAAhB,AAAA,AAAAiC,AAAA;AAAAC;AAAA,AAAA,AAAAP,AAAA,AAAA;;AAAA,AAAA,AAAAO,AAAAA;;AAAA,AAAA,AAAAN,AAAA,AAAAC,AAAAK;AAAA,AAAA,AAAAN;AAAA,AAAA,AAAAM,AAAAN;AAAA,AAAA,AAAA,AAAAO,AAAAD;AAAA,AAAAE,AA43EH,AAAA0B,AAAA5B;AA53EGG,AAAA,AAAAC,AAAAF;AAAAG,AAAA,AAAAC,AAAAH;AAAA,AAAA,AAAA,AAAA,AAAAI,AAAA;;AAAA,AAAA,AAAA,AAAAA,AAAAJ;AAAA,AAAA,AAAAK,AAAAN,AAAAK,AACMY;AADN,AAAA,AAAA,AAAAV,AAAAJ,AAAA,AAEGc,AAAUjE;;AAFb,AAAA,AAAAqD,AAAA;;;;AAAA;;;;;AAAA,AAAAG,AAAA,AAAAC,AAAAN,AAAA,AAAAO,AAAA,AAAAC,AAAAb;;AAAA,AAAAU,AAAA,AAAAC,AAAAN,AAAA;;;AAAA,AAAA,AAAAP,AAAAE,AACMmB;AADN,AAAA,AAAAL,AAAA,AAAA,AAAAF,AAAA,AAAAG,AAAAf,AAEGmB,AAAUjE;;;AAFb;;;;;AAAA,AAAA;;;AAAA8D,AAAA,AAAArB,AAAA,AAAAI,AAC4BjC;AAD5B,AAAA,AAAAkD;AAAA,AAAAC,AAAAD,AAAA,AAAAE,AAAA,AAAAH,AAAAvB;;AAAA,AAAA,AAAAuB,AAAAvB;;;;;AAAA;;;;AAAA,AAAA;;AAAA,AAAA,AAAAD,AAAA,AAAAxC,AAA6BN;;;;;AANnF,AAAAM,AASGqC;;AAEH,AAAegC,AACb,AAAA,AAAC1E;AAEH;;;AAAA,AAAM2E;AAAN,AAGE,AAAA,AAAAtE,AAAWqE;AAAX;AAAA,AACE,AACE,AAAA,AAAArE,AAAWqE;AAAX;AAAA,AACE,AAAC9B,AAAO8B,AAA0B,AAAC5C,AAAgB,AAAA,AAAAzB,AAAC4C,AAAK/C;;;;AANjE,AAAAG,AAOGqE;;AAGH,AAACE,AAES,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAApC,AAAA,AAAA,AAAAA,AAAA;AAAA,AAAA,AAAAoC,AAAAA,AAAAA;AAFV,AAIC,AAAKC,AAAEA,AAAEC,AAAIC;AAAb,AACE,AAAU,AAACC,AAAEF,AAAIC;AAAjB;;AAAA,AACE,AAAA,AAACpC,AAAOF;;AACR,AAAA,AAACE,AAAO8B;;;AAIb,AAAA,AAACE,AACA7E,AAEA,AAAK+E,AAAEA,AAAEC,AAAIC;AAAb,AACE,AAAU,AAACC,AAAEF,AAAIC;AAAjB;;AAAA,AACE,AAAA,AAACpC,AAAOF;;;AAEb,AAAA,AAACkC,AACA1E,AAEA,AAAK4E,AAAEA,AAAEC,AAAIC;AAAb,AACE,AAAU,AAACC,AAAEF,AAAIC;AAAjB;;AAAA,AACE,AAAA,AAACpC,AAAO8B","names":["js/metabase","js/metabase.types","js/metabase.types.coercion-hierarchies","js/metabase.types.coercion-hierarchies.strategy->allowed-base-types","metabase.types.coercion-hierarchies/strategy->allowed-base-types","cljs.core.atom","js/metabase.types.coercion-hierarchies.strategy->effective-type","metabase.types.coercion-hierarchies/strategy->effective-type","js/metabase.types.coercion-hierarchies.non-descending-base-type->strategy","metabase.types.coercion-hierarchies/non-descending-base-type->strategy","cljs.core/deref","metabase.types.coercion-hierarchies/non-descending-strategies","metabase.types.coercion-hierarchies/effective-type-for-strategy","strategy","cljs.core.get","metabase.types.coercion-hierarchies/one-or-many","x","cljs.core.some_fn","cljs.core/sequential?","cljs.core/set?","cljs.core/nil?","metabase.types.coercion-hierarchies/define-types!","coercion-strategy","base-type-or-types","effective-type","base-types","cljs.core/set","cljs.core.swap_BANG_","cljs.core/assoc","metabase.types.coercion-hierarchies/define-non-inheritable-type!","cljs.core.partial","cljs.core/merge-with","clojure.set/union","cljs.core/zipmap","cljs.core.repeat","metabase.types.coercion-hierarchies/build-hierarchy","pairs","cljs.core.reduce","p__36321","vec__36322","cljs.core.nth","h","tag","parent","cljs.core.derive","fexpr__36329","cljs.core/get-global-hierarchy","metabase.types.coercion-hierarchies/base-type-hierarchy*","metabase.types.coercion-hierarchies/base-type-hierarchy","cljs.core/reset!","iter__4529__auto__","s__36339","cljs.core/LazySeq","temp__5735__auto__","cljs.core/seq","xs__6292__auto__","vec__36346","cljs.core/first","iterys__4525__auto__","s__36341","cljs.core/chunked-seq?","c__4527__auto__","size__4528__auto__","cljs.core/count","b__36343","cljs.core/chunk-buffer","i__36342","cljs.core/-nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__36340","cljs.core/chunk-rest","cljs.core/cons","cljs.core/rest","fs__4526__auto__","cljs.core.concat","iter__36338","base-type","metabase.types.coercion-hierarchies/effective-type-hierarchy*","metabase.types.coercion-hierarchies/effective-type-hierarchy","cljs.core/add-watch","fexpr__36375","_","old","new","cljs.core._EQ_","cljs.core/chunk-first"],"sourcesContent":["(ns metabase.types.coercion-hierarchies\n  (:require [clojure.set :as set]))\n\n;; these need to be defonce so we don't drop our hierarchies, but defonce doesn't support docstrings:\n;; https://clojure.atlassian.net/browse/CLJ-1148\n\n(defonce ^:private\n  ^{:doc \"Map of `coercion-strategy -> #{allowed-base-type}`.\"}\n  strategy->allowed-base-types\n  (atom {}))\n\n(defonce ^:private\n  ^{:doc \"Map of coercion strategy -> resulting effective-type\"}\n  strategy->effective-type\n  (atom {}))\n\n(defonce ^:private\n  ^{:doc \"Map of base-type -> #{strategy} which are not inheritable. Eg, binary fields are marked `type/*` and may be coerced\n  to timestamps with `:Coercion/YYYYMMDDHHMMSSBytes->Temporal` but we don't want all children of `type/*` to be\n  coerced as such.\"}\n  non-descending-base-type->strategy\n  (atom {}))\n\n(defn non-descending-strategies\n  \"Get a map of strategies -> allowed-base-types. These must live outside of the hierarchy.\"\n  []\n  @non-descending-base-type->strategy)\n\n(defn effective-type-for-strategy\n  \"Gets the effective type for strategy. Essentially a getter over the\n  private strategy->effective-type.\"\n  [strategy]\n  (get @strategy->effective-type strategy))\n\n(defn- one-or-many\n  \"Ensure x is a sequential collection. Copied from metabase.util as that namespace is not amenable to cljc.\"\n  [x]\n  (if ((some-fn sequential? set? nil?) x) x [x]))\n\n(defn define-types!\n  \"Define the `base-type-or-types` allowed and the resulting `effective-type` of a `coercion-strategy`.\"\n  [coercion-strategy base-type-or-types effective-type]\n  (let [base-types (set (one-or-many base-type-or-types))]\n    (swap! strategy->allowed-base-types assoc coercion-strategy base-types))\n  (swap! strategy->effective-type assoc coercion-strategy effective-type))\n\n(defn define-non-inheritable-type!\n  \"Define coercion strategies that should not exist for all of the descendants of base-type-or-types.\"\n  [coercion-strategy base-type-or-types effective-type]\n  (swap! non-descending-base-type->strategy\n         (partial merge-with set/union)\n         (zipmap (one-or-many base-type-or-types) (repeat #{coercion-strategy})))\n  (swap! strategy->effective-type assoc coercion-strategy effective-type))\n\n(defn- build-hierarchy [pairs]\n  (reduce\n   (fn [h [tag parent]]\n     (derive h tag parent))\n   #?(:clj @#'clojure.core/global-hierarchy\n      :cljs @(#'clojure.core/get-global-hierarchy))\n   pairs))\n\n;; atom is nil => rebuild the hierarchy\n\n(def ^:private base-type-hierarchy*\n  (atom nil))\n\n(defn base-type-hierarchy\n  \"The global hierarchy, with coercion strategies added as ancestors of their allowed base type(s).\"\n  []\n  (when-not @base-type-hierarchy*\n    (locking base-type-hierarchy*\n      (when-not @base-type-hierarchy*\n        (reset! base-type-hierarchy* (build-hierarchy (for [[strategy base-types] @strategy->allowed-base-types\n                                                            base-type             base-types]\n                                                        [base-type strategy]))))))\n  @base-type-hierarchy*)\n\n(def ^:private effective-type-hierarchy*\n  (atom nil))\n\n(defn effective-type-hierarchy\n  \"The global hierarchy, with coercion strategies added as children of their resulting effective type.\"\n  []\n  (when-not @effective-type-hierarchy*\n    (locking effective-type-hierarchy*\n      (when-not @effective-type-hierarchy*\n        (reset! effective-type-hierarchy* (build-hierarchy (seq @strategy->effective-type))))))\n  @effective-type-hierarchy*)\n\n;; rebuild coercion hierarchies if the global hierarchy changes\n(add-watch\n #?(:clj #'clojure.core/global-hierarchy\n    :cljs (#'clojure.core/get-global-hierarchy))\n ::rebuild-hierarchies\n (fn [_ _ old new]\n   (when-not (= old new)\n     (reset! base-type-hierarchy* nil)\n     (reset! effective-type-hierarchy* nil))))\n\n;; rebuild coercion hierarchies if the type map atoms change\n\n(add-watch\n strategy->allowed-base-types\n ::rebuild-hierarchies\n (fn [_ _ old new]\n   (when-not (= old new)\n     (reset! base-type-hierarchy* nil))))\n\n(add-watch\n strategy->effective-type\n ::rebuild-hierarchies\n (fn [_ _ old new]\n   (when-not (= old new)\n     (reset! effective-type-hierarchy* nil))))\n"]}